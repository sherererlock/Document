# A tour of Granite’s Vulkan backend – Part 6

# Pipelines – what is your pain tolerance?

管线的创建需要深思熟虑。是急切地创建还是懒惰地创建，使用动态渲染状态还是静态渲染状态。忘记一切都适用的想法。你会有多接近火山呢？确保完成后脚下没有熔岩。

我的痛苦耐受力有点低，我宁愿在电视上观看。花岗岩有点类似，它更喜欢成为冷却的岩浆。

### The ideal case

Vulkan被设计成让你忘记那些肮脏的渲染状态管理，而专注于与纯净的VkPipeline对象一起工作。这些对象编码了你在GPU上翻转固定功能位和零件时可以做出的每一个可能选择。

达到只考虑VkPipeline的程度，并且所有管线在加载时都预先编译完成，是现代图形API实现的终极目标。不再有卡顿、顿挫和令人沮丧的100毫秒故障，当你窥视墙角时，它们会使你措手不及。

要达到这一点，你必须牺牲所有灵活性的概念，不能有最后一刻的决定，一切都必须提前详细计划。有很多状态被汇聚在一起形成一个VkPipeline，这是一个五彩缤纷的明星阵容和一个具有深度的情节。

... 嗯，这有点奇怪。

#### Shader modules

显然，管线的核心部分是着色器模块，在Granite中是Vulkan::Program。通过程序，我们自动了解VkPipelineLayout，因为它具有反射功能，所以在这方面没有问题。

#### Render pass

我们还需要知道渲染通道（以及子通道索引！）才能创建管线。这个问题可能真的很反直觉。着色器编译器通常需要知道哪些渲染目标格式正在使用，以便生成最终的ISA。这就是我们开始遇到问题的地方。没有明显的理由将渲染通道和着色器模块结合在一起。在我的心智模型中，这两者不应该互相了解，但驱动程序确实希望如此。例如，如果我要渲染一个场景，流程会是这样的：

1. 开始渲染到一些附件（这里已知VkRenderPass）
2. 设置适合该通道的默认渲染状态。对于仅深度、不透明、光照和透明度渲染，有不同的“默认”状态。渲染状态向量的一部分在此确定。
3. 请求渲染器渲染一些经过剔除的可见对象列表。在此级别已知着色器模块，并且一些渲染状态可能是每个材质特定的，例如双面渲染等。

有几种方法可以解决这个问题，但是你必须在某个地方拥有更高级别的知识，了解着色器模块在哪些渲染通道中使用。如果应用程序在构建过程中有烘焙步骤，那可能是一个很好的地方，但并非所有图形API用例都是这样的。仿真也是一种情况，其中你无法知道应用程序会执行什么操作，直到执行它。用户脚本编写也可能是一场噩梦...

渲染通道还有很多组合爆炸。如果我们仅从MSAA 2x更改为MSAA 4x，那意味着新的渲染通道和与这些渲染通道兼容的新管线。显然，我们看到类似于在大多数游戏的选项菜单中更改设置这样的微不足道的更改，会导致所有材质的完全不同的管线集。这种耦合并不是我所说的干净，但有时为了性能必须牺牲理智。我宁愿保持理智。

#### Fixed-function vertex bindings

这包括属性、绑定、步长和输入速率。如果你控制资产管线，通常这不是一个问题。你可以决定一个“标准”的顶点缓冲区布局，然后忘记它。如果我们想要支持glTF或其他场景传输格式，除非我们准备重新编写所有顶点缓冲区以匹配标准布局，否则这里会有一些轻微的烦恼。

着色器编译器喜欢知道这些信息，因为一些ISA需要在软件中获取顶点，因此需要能够根据VertexIndex/InstanceIndex计算出正确的偏移量。

#### 10 – Fixed-function render state

在Vulkan中渲染三角形时，仍然有大量的状态需要处理。Vulkan将你在glEnable/glDisable和其他各种函数中设置的所有东西捆绑到一个庞大的结构中。我写了一个示例来演示如何设置、保存和恢复渲染状态。

我必须承认，我有点喜欢以前逐个设置状态的老式方式。将渲染状态隔离到命令缓冲区中可以避免OpenGL中状态管理的几乎所有可怕问题。在OpenGL中，状态是全局的，并且在模块和渲染通道之间泄漏。这真的很可怕，你基本上被迫在GL之上构建一个自定义状态跟踪器，以保持理智。还没有好的方法只“保存”你关心的状态并在不编写大量自定义代码的情况下进行恢复。我喜欢设置一些“标准”状态的想法，清除任何可能的状态泄漏。总的来说，Granite的模型提供了最大的便利性。

我在其他项目中看到的一个概念是在用户端创建大型结构，模拟管线的想法，但我认为除非它基本上是一个带有所有花哨功能的完整VkGraphicsPiplineCreateInfo，否则这并不是很有用。如果不这样做，我们仍然无法获得创建管线所需的信息，例如渲染通道信息，然后我们又回到了懒惰创建和散列。

对我来说，即使只是渲染状态也倾向于分为两半。一些状态倾向于具有“全局”性质，一些状态倾向于具有“局部”性质。这是由更高级别的渲染器设置的状态，它从以下方面思考：

- 不透明通道与透明通道（alpha混合）
- 仅深度？（深度写使能，深度偏置？，等测试？）
- 光照通道？（加法混合？）
- 模板？（用于延迟渲染）
这些状态根据需要保存和恢复，然后我们有在渲染通道中渲染的对象，通常从以下方面考虑：

- 双面网格？（面剔除）
- 基本重启？
- 拓扑？
- 着色器程序？
- 顶点属性？
我不喜欢将渲染器的这些部分耦合在一起，因此Vulkan::CommandBuffer中的紧凑状态块对我来说是足够的。归根结底，这种灵活性的唯一真正成本是一些额外的散列成本。对我来说，它在性能分析中并不突出。

总的来说，我喜欢CommandBuffer接口的“即时”特性。如果有必要，始终可以使用混合解决方案，在其中设置我感兴趣的状态，然后提取持久的VkPipeline句柄，以供以后使用，并绕过绑定时的任何状态散列。

#### Avoiding stutters

在我看来，延迟创建管线的真正问题在于vkCreateGraphicsPipelines。在最后一刻进行这样的操作几乎肯定会产生延迟，应尽一切可能避免这种情况发生。避免最后一刻编译管线的真正原因是我们应该在开始时就了解所有状态组合，而不仅仅是因为我们可以直接绑定VkPipelines并避免一些小型散列成本。

我处理这个问题的策略是使用先前看到的数据预热哈希映射。Granite集成了Fossilize项目，以在与GPU和驱动程序无关的方式解决序列化所有创建管线所需信息的问题。理论上，我可以将Fossilize数据库作为应用程序的一部分进行发布，并在Vulkan::Device创建时使用它来预热所有历史观察到的管线及其相关对象。

据我所知，这基本上是所有GL和D3D11驱动程序的行为方式。缓存所有的东西。

### Conclusion

Granite的渲染状态管理是老式的，但我喜欢它。在Vulkan::Device中预热各种哈希映射是我用来避免管线编译延迟的策略。

任何图形API抽象都有许多替代方案。在传统API中有我喜欢的东西，也有我讨厌的东西。我想保留我喜欢的部分，避免我不喜欢的部分。

### … that’s all folks!

我明白了。我认为现在是这个系列的结束。我已经大致介绍了Vulkan后端，希望这对你来说既有趣又有用。