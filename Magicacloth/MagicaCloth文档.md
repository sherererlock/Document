## MagicaCloth文档

#### MagicaCloth参数解析

https://magicasoft.jp/en/mc2_bonecloth_mesh/

### BoneCloth

![image-20230425184017959](C:\Users\admin\Desktop\工作总结\magicacloth_bonecloth.png)

BoneCloth有一个从注册的Transform自动构建网格的功能。通过使用这个功能，Transform之间的连接变得更强，形状维护和碰撞检测也变得更强。
另外，由于边缘是水平连接的，你可以通过与边缘碰撞一起使用来进一步加强碰撞检测。
设置是由BoneCloth的[Connection Mode]进行的。目前，有三种类型的连接方法可供选择。作为一个例子，我们将解释由10根骨头形成的裙子的连接方法的特点，如下所示。

##### AUTOMATIC MESH

自动连接附近的Transform。但是，根据Transform的位置，形状可能不自然。

##### SEQUENTIAL LOOP MESH

按照Root Bones的顺序进行水平连接。因此，Root Bones的注册顺序很重要。根骨的开始和结束是以循环方式连接的。

#### Transform interpolation rate

BoneCloth可以调整每个Transform的旋转姿态。

参数每一个Transform最终面向它所连接的父或子的插值率。

##### ROOT ROTATION

一个Fixed Transform的旋转调整。
0.0---不从原始姿态旋转。
1.0----沿着Child的变换方向旋转。多个Child是平均的。
0.5处于中间位置。

##### ROTATIONAL INTERPOLATION

move Transform的旋转调整。
0.0 --- 沿着父transform的方向旋转。
1.0 --- 在子transform的方向上旋转。
多个child是平均的。
0.5处于中间位置。

一个终端Transform 没有child，所以它总是沿着它的父代方向旋转。

为了达到理想的运动效果，参数调整是不可缺少的。
在这里，我们将解释基线的概念，它与参数有着深刻的关系，以及每个参数的作用。

#### Understand the baseline

在设置参数时，理解基线概念是至关重要的。 基线是从代理网格的固定顶点开始，并沿着表面连接到末端移动顶点的路径
MagicaCloth沿着这个基线恢复形状。 因此，我们实现了一个2.5D般的行为，结合了2D般的动作，同时保留了物理上逼真的动作

##### START/END AND DEPTH

基线包含起点和终点，以及深度信息。
你可以通过在gizmo设置中打开【基线】和【深度】来检查。
让我们以前面的变形结构为例。
白色数字代表深度，起点是（0.0），终点是（1.0），所以你可以查看每个顶点对应的深度。
这个深度值是参数设置的一个重要指标。

深度是自动分配的，因此（1.0）是代理网格中最长基线的终点。

##### BASELINE WITH BONE CLOTH

在BoneCloth中，基线是由Transform的树状结构简单构建的。
所以它和Transform的层次结构是一样的。

MeshCloth稍微复杂一些，基线是根据固定顶点周围的表面连接自动计算的。

#### Relationship between depth and parameters

如上所述，当基线被创建时，为每个顶点设置了一个深度。
这个顶点的**深度**是调整参数时的一个重要指标。
MagicaCloth有许多参数是根据这个深度来确定数值的。

作为一个例子，让我们看一下限制角度的Angle Limit动作。
Angle Limit限制了基线的边缘可以弯曲的角度。
这个Angle Limit的设置面板看起来像这样：

横轴是深度（0.0到1.0），纵轴是参数的强度（0.0到1.0）。

当深度为0.0时，强度为0.2，所以极limit angle为60 x 0.2 = 12度。
在深度（0.5）时，强度是0.6，所以limit angle是60 x 0.6 = 36度。
在深度（1.0），强度是1.0，所以limit angle是60×1.0=60度。

将此与前面的BoneCloth深度图结合起来。
顶点深度（0.0~1.0）直接对应于曲线的水平轴。
我希望你能理解每个顶点接受的极限角度是如何确定的。

这样一来，曲线参数就有了一个机制，最终的数值是和深度一起计算的。
这就是深度和参数之间的关系。
记住，这适用于所有带有[C]按钮的参数。

### Parameter type

在这里，我们将按类型介绍究竟有哪些参数。
如果详细解释每个参数的功能，页数会非常多，所以这里我们将重点介绍参数的概况和设置指南。
有关参数的细节，请参考单独的参考资料。

##### FORCE

控制重力和空气阻力（阻尼）等力量。
增加一些重力会使运动更加真实。
如果你降低空气阻力，顶点将不容易静止。
反之，如果你增加空气阻力，顶点就会慢慢移动。

Gravity Falloff可以根据cloth的方向减少重力的影响。
例如，如果Falloff是1.0，如果布的角度与初始姿态相同，就不会有重力作用。

##### ANGLE RESTORATION

将baseline 的每个edge 旋转回原来的位置。
**Angle Restoration是控制运动的最重要参数。**
可以毫不夸张地说，大部分运动都是在这里决定的。

Stiffness 是指一次修正的旋转角度的数量。
**增加Stiffness 可以加快恢复的速度**。

速度衰减（Velocity Attenuation）是在修复过程中应用于顶点的速度衰减量。
**如果你降低它，加速度会更强，会像弹簧一样反弹**。

调整这两个属性需要一定的熟悉程度和经验。
一个好的开始是加载一个预设并尝试模仿它。

##### ANGLE LIMIT

限制baseline 的每个edge 可以从其原始姿势弯曲的角度。
当你不想像刘海那样弯曲太多，它是有效的。
将裙子的角度限制在一定程度上也是一个好主意，以保持其形状。

##### SHAPE RESTORATION

它做三个动作来保持代理网格的形状

|                  |                                                              |
| ---------------- | ------------------------------------------------------------ |
| Distance         | 网格的可伸缩性。<br/>移动时保持每个顶点与相连顶点之间的距离不变。<br/>通常情况下，1.0就可以了。 |
| Tether           | 限制一个顶点离其baseline起点的最小距离。<br/>只有收缩范围可以设置。<br/>如果降低压缩范围，**顶点将无法接近其起点**。<br/>反之，如果提高它，**顶点将能够自由移动**。<br/>**降低该值会使网格的形状更难变形**。<br/>这可以避免出现布片过度收缩的现象。<br/>但是，在某些情况下，由于运动的自由度降低，运动可能会很笨拙。<br/>一般来说，建议将其设置为0.8或更高，并有限度地减少。 |
| Triangle Bending | 网格对弯曲的阻力。<br/>它的作用是将相邻的三角形恢复到它们的原始角度。<br/>这对保持网格的形状起着重要作用。<br/>通常1.0就可以了。<br/>如果代理网格中没有三角形存在，则什么都不做。 |

##### INERTIA

决定cloth 的运动如何影响顶点。
这是继角度恢复之后确定运动的第二个最重要的参数。

一块cloth 总是有一个中心点。
这是从固定属性的分布中自动确定的，并在场景视图中显示为一个紫色的球体的Gizmo。

当这个中心移动时，它的平移和旋转力会传递给顶点。
限制运动力的是惯性参数。

例如，**如果抖动对于角色的运动来说太大，你可以添加限制条件来抑制整体抖动。**
**有四种类型的限制，每一种都有自己的特点**：

###### Movement Inertia Rotation Inertia

减少移动力或旋转力本身。
例如，如果该属性为0.1，只有1/10的布的运动将被添加到顶点。
这使得即使布的运动速度很高，也可以抑制晃动。

然而，即使布的移动速度很慢，运动力也会减少，所以也有不利的影响，即晃动变得极小。

###### Depth Inertia

用顶点深度减少惯性。
简单地说，如果你增加这个属性，深度越接近起点，它就越难移动。
端点不受减少的影响。

当你不想让起点周围的区域移动太多，例如裙子或头发，这就很有效。
然而，请注意，如果起点附近的惯性被减少，整体的运动就会变弱。

###### Movement Speed Limit Rotation Speed Limit

在设定的速度下削减运动力或旋转力。
例如，如果Movement Speed Limit=2.0，如果角色的移动速度在2m/s以内，力就会按原样传输，如果超过2m/s，无论顶点移动多快，都不会再受力了。
有了这个限制，无论你是缓慢移动还是高速移动，你都可以在一定程度上限制晃动。

基本上，我们推荐使用这个，而不是运动惯性/旋转惯性。

###### Particle Speed Limit

限制了每个顶点的最大速度。
这可以缓解长带状物体的顶端由于离心力而过度向外凸出的现象。

但是，如果你把这个值降低到1.0（1米/秒）以下，碰撞检测的准确性就会下降，所以降低这个值时要小心。

##### MOVEMENT LIMIT

限制顶点相对于proxy mesh的顶点法线方向的移动。
这也被称为backstop。

它的工作原理见上图。
简单地说，顶点只能在MaxDistance范围内和BackstopCollision之外移动。

例如，假设你有一件T恤，所有顶点法线都指向人体外侧。
在这里，我们使用逆止函数来限制顶点在法线的反方向上进入超过一定距离。
这可以防止T恤衫在不使用碰撞碰撞器的情况下钻入人体。
利用同样的原理，也可以很容易地防止刘海挖到头的内部。

重要的是，它是在代理网格的顶点法线上计算的。
记住，渲染网格的顶点法线是不相关的。
另外，作为约束基础的顶点位置和法线是在模拟之前从带皮的代理网格的姿势中获得的。
而且，代理网格的法线也可以进行调整。

backstop的解释有点长，所以请参考backstop的解释页面了解更多细节。

##### COLLIDER COLLISION

这是最经常使用的碰撞控制，使用球体和胶囊等碰撞器来限制布条进入人体。
碰撞器的碰撞检测在碰撞检测设置里有详细解释，所以请参考。

##### SELF COLLISION

在这里，你可以设置自我碰撞以防止Cloth穿透Cloth，以及相互碰撞以防止Cloth穿透其他布匹。

如果你使用自我碰撞，布本身就会像图像一样发生碰撞。
然而，自我碰撞需要大量的碰撞计算，所以负载非常高。
因此，建议在台式电脑或高端控制台机器上使用它。

还要注意的是，自我碰撞目前是一个实验性功能，即处于测试阶段。
因此，行为和设置在未来可能会改变。
有关自我碰撞的更多信息，请参见专用页面。

#### Tuning tips

到目前为止，我已经解释了每个参数的作用。
你所要做的就是重复试验和错误，以更接近理想的运动。
然而，这项工作是非常困难的，所以我想发表一些调整技巧。

##### ADJUST IMPORTANT PARAMETERS FIRST

虽然参数的数量很多，但真正决定运动的只有几个项目。
首先尝试调整这些。

| Force             | 重力和空气阻力<br/>这与顶点运动有很大关系。                  |
| ----------------- | ------------------------------------------------------------ |
| Angle Restoration | 旋转重建<br/>这是最重要的参数，决定了整体运动。<br/>最好先从这里开始调整。 |
| Inertia           | 如果角色跑动或跳跃时，布条移动太多，可在此调整。             |

##### ADJUSTABLE ON THE FLY

参数也可以在运行时从检查器中调整。
在实际玩游戏的时候进行调整，使试错更容易。

##### TAKE ADVANTAGE OF PRESETS

预置是设置参数的快捷方式。
首先，让我们加载一个预设，检查它是否接近理想的运动。
如果你有一个接近理想运动的预设，你就可以通过从那里独立调整参数来减少时间。

##### SAVING PRESETS

将你辛苦调整的参数保存为预置。
保存的预设可以通过预设按钮轻松设置。
通过这样做，你可以在设置类似动作时节省大量的工作。
在运行时也可以保存预设。

##### TAKE ADVANTAGE OF COMPONENT COPIES

调整的麻烦在于，执行过程中调整的检查器的内容在执行结束后会全部恢复。
使用组件复制功能可以避免这种情况!
这个功能允许你在执行过程中按下组件的"︙"按钮来复制检查器的内容。

### Backstop

Backstop 是一种碰撞检测，它根据顶点的法线方向来限制可以进入的距离。
通过使用它，你可以轻松地防止刘海等穿透你的头部。
它还可以防止T恤衫和其他物品进入人体。
该机制很简单，处理负荷很低，是一个能有力防止侵入人体的系统。

#### Structure

逆止原理很简单。
限制了代理网格的每个顶点相对于法线方向的移动范围。

![img](C:\Users\admin\Desktop\工作总结\mc2_param_setup-23.jpg)

上图显示了配置属性和它们的限制。
代理网格的顶点和法线显示的是动画的姿态，也就是原点，而不是当前的平移位置。
首先，顶点只能在以原点为中心、半径为最大距离的球体内移动。
这是第一个限制。

然后，顶点只能在以原点法线为半径的Backstop Collision球体外移动，其距离为Backstop Radius。
这是第二个限制。

这两个限制意味着顶点只能在最大距离内和逆止点碰撞之外移动。
你可以同时使用这个限制，也可以只使用其中一边。

#### Setting example of bangs

让我们以刘海为例。
我们将使用逆止器来防止刘海进入头部。

![img](C:\Users\admin\Desktop\工作总结\mc2_backstop-1.jpg)

BoneCloth提前设置了刘海，使其摇曳生姿。

##### CHECK NORMAL DIRECTION

首先，让我们检查一下当前代理网格的法线方向是什么。
这将通过将Gizmo面板中的轴设置为法线来显示。

绿线是法线方向。
顶点球体被隐藏起来，以便于观察。

BoneCloth只是使用了Transform的Y轴，所以这个模型有一个混乱的方向。
在这种状态下，Backstop是不可用的。

##### NORMAL ADJUSTMENT

让我们来调整法线方向。
理想情况下，所有法线都指向头部以外。
通过Normal Axis和Normal Alignment属性来进行调整。

在Transform模式下，法线会以指定的Transform坐标为基准进行径向改变。
这种改变是针对代理网格的，并不影响原始的Transfrom或网格。
现在我们准备设置逆止器，所有的法线都指向头部之外。

##### BACKSTOP SETTING

你所要做的就是设定你可以入侵的距离。
这次我做了以下工作：

使用了一条曲线，所以可以从起点到终点，从0厘米到5厘米。
这次没有使用最大距离。
刚度是指斥力的强度。
降低这个值会使顶点的移动变得更柔和一些。

*角色被左右移动。
我能够不使用碰撞器，防止头发进入头部。

#### Skirt setting example

在这里，我们将以裙子为例解释高级逆止器的设置。
逆止器主要是防止顶点穿透人体。
然而，人体总是被动画化的，其姿态也会有各种变化。
正因为如此，它不会像上面提到的刘海那样简单。

##### IMPORTANCE OF ANIMATION POSTURE

动画的姿态在这里很重要。
这是在不使用MagicaCloth的情况下，Transform或Mesh为动画变形的姿势。

例如，下面的角色有一条裙子，裙子的皮肤是在左右腿上。
因此，裙子跟着腿走，并产生动画。
这很理想，在这种情况下，你可以设置一个逆行。

然而，下面这个角色的裙子并没有与腿部形成皮肤。
因此，当执行动画时，腿部会穿过裙边。
在这种状态下不能设置逆止。

逆止器对动画的姿态进行了限制。
为了使逆止器发挥作用，变形或网格必须紧跟动画。

##### ANIMATION POSTURE ADJUSTMENT

解决上述问题的最好方法是设置skinning weights ，使网格跟随腿部。
或者，在裙子上添加一根骨头，并在每个动作（如跑、跳、攻击等）中控制骨头的动画，在一定程度上控制姿势。
这通常是由艺术家用外部工具（如Blender）完成的。

在美术创造的动画姿势上叠加布匹模拟的方法是最稳健的，可以防止对人体的侵袭。
建议采用这种方法。

如果这种方法不可行，你也可以使用后面介绍的custom skinning 功能作为替代。

##### CHECK ANIMATION POSTURE

你可以用一个小工具显示当前动画姿态的状态。
你可以通过打开动画姿态检查来检查，方法如下。

##### USING CUSTOM SKINNING

如果由于某些原因艺术家修正是不可能的，有一个custom skinning功能作为替代。
这是一个自动为指定骨骼的代理网格 skins 的功能。
如果动画的姿势已经设置正确，则没有必要。

打开 "custom skinning "面板中的检查，在 "Skinning "中注册换肤所需的骨骼。
对于KAGURA的裙子，我注册了从胸部到两条腿的骨头，如下所示。

这将使逆止器发挥作用。
也可在BoneCloth中使用。

但请记住，custom skinning只是一个替代功能。
因此它不是很准确。

##### PAINT VALID VERTICES

逆止器可以为每个顶点设置有或没有功能。
这可以通过在面板中的蓝色笔标记中启动顶点绘画来完成。

例如，当你不希望逆止器对网状物的特定部分起作用时，可以使用它。

##### BACKSTOP SETTING

在这之后，你所要做的就是像刘海的例子一样，设置逆行。
这一次，我们将为KAGURA的裙子设置自定义换肤。
为了使效果更容易理解，我们把无入距离设置为0厘米。

这是一个仅有逆止器的控件，不使用任何碰撞器的碰撞。
你可以看到，逆止器限制了腿部的运动，并阻止顶点进入腿部。
同时注意到，没有顶点侵占腰部周围。

通过添加一个碰撞器并在这种状态下强化它，你可以控制裙子不穿透腿部，无论你如何移动。

#### Animation posture ratio

这一项与逆止器没有直接关系，但它对控制摇摆很重要，所以我将解释它。

到目前为止，我已经解释了关于动画姿势的问题。
MagicaCloth内部持有初始姿态和动画姿态。
逆止点总是从动画姿势中计算出来的。

然而，一些约束条件可以指定是根据初始姿势还是动画姿势来恢复。
这就是动画姿势比率。
这可以从基本面板中的动画姿态比来完成。

这个值越接近1.0，越是根据动画的姿态来计算修复。
初始值是0.0，修复是根据初始姿态计算的。
换句话说，它是以初始姿态还是以当前动画姿态为目标进行恢复的比率。

如果比率为0.0，将产生一个恢复力来恢复到初始姿势。
如果比率是1.0，将产生一个恢复力来恢复到当前的动画姿态。
如果比率为0.5，将以1:1的比例混合两种姿态。

##### AFFECTED CONSTRAINTS

有三个约束条件受到这个动画姿势比例的影响：

1. Angle Restoration
2. Angle Limit
3. Shape Restoration

##### SETTING GUIDELINES

基本上，让它保持在0.0就可以了。
这是因为在大多数情况下，布的运动是比较稳定的。

但是，如果动画的姿势有很大的变形，增加比例可能会更稳定。
另外，如果动画的姿势完全由艺术家控制，更高的数值会更稳定。
在这种情况下，试着从0.5左右的设置开始调整，同时观察运动情况。

### Runtime Construction

MagicaCloth2完全支持运行时构建。
这里我们将解释如何在运行时从脚本中构建MagicaCloth组件。
假设读者熟悉Unity中的C#编程。

### Runtime Changes

MagicaCloth2支持在执行过程中改变参数。
在这里，我将解释如何在执行过程中操纵脚本的参数。
假设读者熟悉Unity中的C#编程。

### Change procedure

1. 获取MagicaCloth组件的SerializeData类
2. 改变SerializeData的内容
3. 调用MagicaCloth组件的SetParameterChange()

### Dress-up process

本节介绍了如何将MagicaCloth移植到另一个角色。
如果你想用不同的头发和服装来装扮你的游戏角色，这很有用。
假设读者熟悉Unity中的C#编程。

#### How to change your clothes

1. 生成预制的敷料
2. 停止MagicaCloth的自动构建
3. 将渲染器移植到骨骼化身上
4. 将MagicaCloth移植到骨骼头像上
5. 将碰撞器和其他项目移植到骨骼化身上
6. 开始运行MagicaCloth

### Performance

本节讨论了各种与性能有关的问题。
这些内容主要是为程序员准备的。

#### MagicaCloth performance dependent

MagicaCloth在Unity DOTS（(Data-Oriented Technology Stack）上运行。
因此，它是完全依赖CPU的。
反之，它完全不使用GPU。

此外，DOTS支持多线程，所以CPU核心（线程）的数量越多，性能越好，因为可以并行执行。

然而，在Android/iPhone上使用它时，必须谨慎一点。
移动设备中的CPU一般都是以大核心配置和小的低功耗核心配置组成。
这被称为大-小配置。
例如，即使一个终端有一个8核CPU，在大多数情况下，它被分为Big4/Little4等。
在这种情况下，它被描述为（4-4核）。
Unity将只在大核上运行DOTS。
因此，在上述设备的情况下，8个核心中只有4个可以用于DOTS。
请注意这一点。

这个问题不会发生在台式电脑CPU上。

#### Creation and execution of cloth data

MagicaCloth需要各种数据来进行模拟。
这被称为cloth data。
cloth data在运行时按要求即时生成。

这种cloth data的创建需要大量的计算处理，通常需要20ms到100ms。
这个创建过程是在一个后台线程中执行的，所以对主线程的影响很小。
此外，多个cloth被创建在多个线程中，这些线程是平行执行的。

然而，simulation 必须等待，直到这个cloth data被完成。
这导致角色的实际创建和模拟的开始之间有几帧的延迟。

### Notes on Editor Execution

MagicaCloth使用的Burst和JobSystem在运行编辑器时比构建时要求更高。
因此，请注意，当编辑器运行时，剖析器的内容与构建运行时不一样。
这是由以下因素造成的

#### Burst JIT Compiler

只有在编辑器中运行时，Burst才会在运行时（即时编译器）进行编译。
由于这是在游戏开始后进行的，第一次使用MagicaCloth时，编译时间将是几百毫秒或更多。
因此，在编辑器环境中，在播放后第一次模拟开始之前会有很大的延迟。
这个问题只发生在编辑器环境中，而不是在构建时。

为了解决这个问题，可以使用下面的进入播放模式选项。
这位于PlayerSettings的Editor选项卡中。

通过使用输入播放模式，Burst在重复播放操作后不会再被JIT编译。

#### JobsDebugger processing load

在编辑器中，JobsDebugger不断监视作业的运行。
这导致作业的执行时间比平时长，作业之间出现不自然的空隙。
如果你担心负载问题，请按以下方法关闭JobsDebugger。

#### SafeCheck processing load

同样地，编辑环境也被监控为Burst安全。
由于这种负载在一定程度上也会发生，如果你担心，请关闭以下两个检查。

#### Note that errors will no longer be reported.

但是，请注意，如果你如上所述关闭JobDebugger和SafeCheck，Burst/Jobs错误将不会被显示。
因此，如果你觉得MagicaCloth工作不正常，请把所有的检查都打开，检查是否有错误。

#### Fastest at build time

请注意，由于各种监控任务，MagicaCloth的性能在编辑器运行时比在构建时低。

在发布的构建中，所有这些监控都被消除了。
因此，最好是在实际设备上构建和检查实际性能。

### List of processing loads

本节介绍了MagicaCloth的功能中最需要处理的部分。
★越多，负荷越大。

| Cloth type |      |                                                              |
| ---------- | ---- | ------------------------------------------------------------ |
| MeshCloth  | ★★★★ | MeshCloth比BoneCloth的要求要高得多，因为除了模拟之外，它还涉及到代理网格换肤和写回渲染网格。<br/><br/>因此，在使用移动设备时，请注意性能问题。 |
| BoneCloth  | ★    | BoneCloth是非常轻的。<br/>在大多数情况下，它可以大量使用而不会造成问题。 |

| Collision processing |            |                                                              |
| -------------------- | ---------- | ------------------------------------------------------------ |
| Self Collision       | ★★★★★★★★★★ | 在所有功能中，自我碰撞是一个突出的、要求高的过程。<br/>因此，它基本上是用于具有大量CPU核心的台式电脑上。<br/><br/>如果在移动设备上使用，尽可能减少代理网格的顶点数量，并密切关注性能。 |
| Mutual collision     | ★★★★★★★★   | 相互碰撞的要求比自我碰撞略低，因为它只确定与对方的碰撞。<br/><br/>然而，由于这个过程与自我碰撞没有什么不同，所以也请密切关注这里的性能。 |
| Edge Collision       | ★★★★       | 边缘碰撞比点碰撞的要求高几倍。<br/><br/>尽量只在点碰撞有问题的情况下使用。 |
| Point Collision      | ★★         | 点碰撞的处理负荷远远低于其他碰撞的确定。                     |
| Backstop             | ★          | 逆止器的处理负荷最低，因为它只需要进行一些计算。<br/>它可以毫无顾虑地使用。 |

### Setting Collision Detection

在这里，我们将解释与人体的碰撞检测，这在模拟角色服装时是不可缺少的。
碰撞检测的设置对于BoneCloth和MeshCloth是通用的。

#### Collision detection type

MagicaCloth有四个碰撞控制机制。

| Collision detection type     |                                                              |
| ---------------------------- | ------------------------------------------------------------ |
| Collider collision detection | 与球体、胶囊和平面等碰撞器的碰撞检测。<br/>这是最常用的方法。<br/>我将在这一页解释。 |
| Backstop                     | 一种通过设置可进入顶点法线方向的距离和半径来防止布进入人体的方法。 |
| Self-collision               | 自我碰撞。<br/>防止布匹钻入自身。                            |
| mutual collision             | 相互碰撞。<br/>防止布匹biting into 他布匹。                  |

#### Principle of Collider Collision

![img](C:\Users\admin\Desktop\工作总结\mc2_collisionsetup-13.jpg)

碰撞器碰撞检测的原理很简单，它的挤压使顶点不侵入碰撞器的形状，如球体和胶囊。

通过根据人体的形状安排这个碰撞器，它是一个防止布进入的机制。

#### Collider type

##### VERTEX SPHERE MODE

将代理网格的顶点视为球体，用碰撞器进行碰撞检测。
球体的大小可以调整。

有一个好处是，你可以不用担心它，因为处理负荷很轻。

但是，如果碰撞器很小，如下图所示，会有一个问题，即它会从球体之间穿过，所以要小心。

##### EDGE MODE

该模式执行代理网格边缘和碰撞器之间的碰撞检测。
边缘厚度可以调整。
边缘模式有一个很大的优点，就是没有球体模式的滑过问题。

然而，应该谨慎使用它，因为其处理负荷比球体模式高。
只有当你在使用VERTEX SPHERE MODE时遇到问题，才应该考虑使用它。

### Reduction

#### Simplifying proxy meshes

注册渲染网格时的代理网格与渲染网格的结构相同。
可以按原样开始模拟，但使用更简单的代理网格在性能和稳定模拟方面有优势。
Reduction 做了这个简化的工作。

|                 |                                                              |
| --------------- | ------------------------------------------------------------ |
| Simple Distance | 它只是将附近的顶点连接起来。<br/>网格的结构不被考虑。        |
| Shape Distance  | 根据网格的形状连接附近的顶点。<br/>没有连接成面的顶点不会被合并，即使它们就在附近 |

#### Adjust while looking at the scene view

通过移动滑动条，代理网格被实时简化并显示在场景视图中。

关于应该做多少简化，请参考以下指标。

- 代理网格越简单，性能就越好。
- 应该简化到在渲染网格中没有细小的突起的程度。
- 如果你简化的太多，碰撞检测就会很弱。
- 而且，渲染网格和代理网格之间的差异可能会增加，显示可能会变得不稳定。

