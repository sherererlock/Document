# A tour of Granite’s Vulkan backend – Part 3

# Shaders and descriptor sets

这是我正在撰写的关于Granite Vulkan后端的博客系列的第三部分。在本篇中，我们将看看我们如何处理着色器和描述符集。在我们的设计过程中，现在有许多选择要考虑。特别是描述符集需要仔细考虑。

### Hash all the things

现在我们开始看到的一个主题是哈希映射和对象的延迟创建。在处理Vulkan与管线相关的类型时，你会遇到的一个问题是始终保持显式的工作量有多大。我们需要提供的信息量令人震惊。我相信在这里一直在低级别工作对心灵和灵魂来说并不健康，除非在特殊情况下，我们应该尽可能隐藏细节。在这里，自然存在着时钟周期与理智之间的权衡。

你可以认为高级GL/D3D11样式设计与Granite模型之间的界限相当模糊。在我看来，为了明确而付出的（精神）代价是不值得的。我将尝试在这里探索明显的替代方案，并提供更多背景，解释设计之所以如此的原因。

### 04 – Shaders and pipeline layouts

创建管线的第一步当然是从我们的SPIR-V代码创建一个VkShaderModule。这是一件轻而易举的事情，但接下来我们需要一个管线布局，而管线布局又需要VkDescriptorSetLayouts。示例在这里https://github.com/Themaister/Granite-MicroSamples/blob/master/04_shaders_and_programs.cpp。

我认为，与其像穴居人一样手动声明管线布局，使用反射自动生成布局是个好主意。用户没有理由复制已经存在于着色器中的信息。对于反射，我使用SPIRV-Cross。如果我们从不需要在运行时编译SPIR-V（游戏引擎场景），那么我们也没有理由不将反射步骤移至离线，只需传递辅助数据以消除运行时依赖性。我从未构建过一个漂亮的离线SPIR-V烘焙管线，所以我只是用shaderc动态地编译GLSL。然而，在Vulkan后端中的接口只是使用原始SPIR-V。

初学者经常犯的一个常见错误是认为在绑定接口中名称很重要。这是从GL和D3D11时代延续下来的错误。我们唯一需要关心的是描述符集、绑定和位置装饰以及推送常量的使用。这是我们创建绑定接口（即管线布局和管线）所需的唯一语义信息。

在Vulkan中，管线布局需要知道所有着色器阶段，就像GL程序一样，因此我们还需要将着色器组合成一个Vulkan::Program。在这里，我们取反射信息的并集，并请求Vulkan::DescriptorSetAllocator和Vulkan::PipelineLayout的句柄。这些句柄被哈希化，但这里没有性能问题，因为我们应该尽可能在加载时进行所有这些工作。这些句柄都由Vulkan::Device在内部拥有，并且没有理由为这些对象担心对象生命周期。

我认为，除非你有一个非常具体的方案要求描述符集分配，否则没有理由偏离这种设计。正如我将在后面探讨的那样，使用无绑定描述符扩展或显式描述符集分配可能会促使使用“标准”管线布局，在这种情况下，反射反而变得有些无意义。

### 05 – The binding model – embracing laziness

我从来没有真正对将资源绑定到绑定槽的老式方式感到困扰。这不是我觉得旧API缺乏的部分，所以在这方面Granite有点老派，但它对描述符集进行了充分考虑，我消除了与Vulkan之间的任何阻抗不匹配（即不需要翻译来桥接Granite和Vulkan之间的差异）。例如：

```
cmd->set_storage_buffer(set, binding, *resource);
cmd->set_texture(set, binding, resource->get_view(), Vulkan::StockSampler::LinearClamp);
```

在GL/D3D11中的旧绑定模型具有平面绑定空间，没有区分每帧、每材质或每次绘制的绑定。在Granite中，我想充分利用描述符集功能，其中我们可以为绑定指定某种“频率”和关系。以下是一个示例，用于说明如何使用它：https://github.com/Themaister/Granite-MicroSamples/blob/master/05_descriptor_sets_and_binding_model.cpp。

在绘制时，我们可以使用当前的管线布局，并提取活动的绑定点，并确保正确绑定具有正确资源的描述符集。这实际上是热点代码，因此我花了时间设计了一个尽可能优化的系统，考虑到这些限制。

由于移动设备的原因，我们需要一些保守的限制。我使用了4个描述符集和每个集合16个（稠密）绑定点（Vulkan的最低规范）。这允许相当紧凑的管线布局描述，并且我们可以循环遍历位集来查看资源。这对于我的用例来说也是完全可以接受的。

当涉及到描述符集本身的分配时，我认为我的方法与大多数人有很大不同。一个Vulkan::DescriptorSetAllocator的表示为：

- VkDescriptorSetLayout
- 一堆只能分配此设置布局的VkDescriptorPools。需要时添加池。
- 一组未使用的VkDescriptorSets池，已经分配并且可以自由更新。
- 一个临时哈希映射，用于跟踪最近请求的描述符集。这使我们可以直接重用描述符集。在理想情况下，我们几乎从不需要调用vkUpdateDescriptorSets。我们最终得到哈希 -> 获取VkDescriptorSet -> vkCmdBindDescriptorSets。当描述符集未使用几帧（8帧）时，我们假设它不再相关，并且集合被回收，其他描述符集可以重用它并只调用vkUpdateDescriptorSet。我们绝对不希望跟踪任何缓冲区或图像资源何时被销毁，并尽早回收。那是跟踪地狱，会减慢一切速度。
- 临时哈希映射是我相当满意的数据结构。它也用于其他一些资源。有关实现，请参阅https://github.com/Themaister/Granite/blob/master/util/temporary_hashmap.hpp。

在某些GPU上，分配描述符集是非常昂贵的，或者至少曾经是非常昂贵的。描述符池可能没有真正实现为真正的池（叹气…），因此每个vkAllocateDescriptorSets都意味着全局堆分配，对性能来说绝对是可怕的。这就是我不喜欢“一个大池”的设计的原因。在这个模型中，我们只分配一个大型的VkDescriptorPool，并且我们只是从中分配，用于任何类型的描述符集。这意味着在许多帧上回收VkDescriptorSet句柄是不切实际的。预期的使用模式是调用vkResetDescriptorPool并分配新的描述符集，这些描述符集一次只能在一帧中有效，就像命令缓冲区一样。还存在一个问题，即如何平衡这些大型池的描述符负载，图像描述符与统一缓冲区描述符的比例是多少等等。使用每个描述符集布局分配器，就不需要任何猜测工作。

#### Alternative design – Bindless

无绑定技术现在非常流行。我唯一真正的抱怨是它仅受支持于桌面平台，并且需要使用一个EXT扩展。它还意味着以一种非常特定的方式编写着色器。对于我的用例，我并不真正需要它，但无绑定技术使得某些复杂的算法受益于动态访问大量资源。

#### Alternative design – persistent explicit VkDescriptorSets

一种替代方案是直接暴露描述符集并且只允许用户绑定描述符集而不是单个资源。API用户需要手动构建这些集合。虽然这是一个想法，但我认为存在太多障碍，使其不太实用：

1. 我们需要预先知道和声明纹理的目标图像布局。这在99%的情况下是很明显的（例如，一组材质纹理，它们是SHADER_READ_ONLY_OPTIMAL），但在某些情况下，特别是深度纹理，事情可能变得相当模糊。这对我来说似乎是API设计的缺陷。不清楚为什么需要这些信息。
2. 一些资源在本质上是完全瞬态的，将它们放在持久性描述符集中是没有意义的。这里的完美例子是统一缓冲区。在后续示例中，我们将看到瞬态数据的线性分配器系统。
3. 一些资源依赖于帧缓冲，即输入附件。为这些资源制作描述符集并不明显，因为我们需要知道组合管道布局 + 帧缓冲，这两者应该没有关联。
4. 我们需要预先知道描述符集布局（以及由此延伸的着色器）。如果资源要在多个着色器中使用，这是有问题的。在这里的常见解决方案是选择一个“标准”的管道布局，以便我们可以将着色器和资源解耦。通常意味着大量填充和冗余的描述符分配。当针对移动设备时，我们有限的描述符集数量（4）意味着我们无法将每个“组”资源分成自己的集合，一些组合效果是不可避免的，使得持久性描述符集变得不太实用。在桌面上，8个集合是常态，因此可能需要考虑这一点。
混合解决方案是可能的，但复杂性增加，而收益微不足道。

### Conclusion

我对我的设计感到满意。它非常易于使用，但我愿意付出一些CPU的代价，而且老实说我从未在性能分析中看到它。我认为资源绑定模型是一种情况，其中削减开销也会削减你的理智，至少如果你想要与各种硬件兼容的话。如果你只针对高端桌面设备进行开发，那就容易得多，因为可以部署bindless技术。

### … up next!

Next up we will explore the linear allocators for uniform, vertex, index and staging data.